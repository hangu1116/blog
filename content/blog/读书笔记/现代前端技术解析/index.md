---
title: 现代前端技术解析
date: "2019-04-27T22:12:03.284Z"
description: "张成文 著"
type: reading
---
```toc
exclude:TableofContents
from-heading:2
to-heading:6
```
## 第1章　Web前端技术基础

### 1.1　现代Web前端技术发展概述

**——页面内容多而复杂**
```mermaid
graph LR
install[Install Plugin]
install --> configure[Configure Plugin]
configure --> draw[Draw Fancy Diagrams]
```
**保证开发效率**：通常，在前端项目实践中，我们需要借助符合特定场景的前端框架来提高开发效率，例如使用jQuery、MVVM等开发框架，对常用的HTMLDOM（DocumentObjectModel，文档对象模型，是指HTML内容通过浏览器解析后建立的具有节点父子关系的树形对象）操作进行高效封装，大大简化开发工作量，提高效率。  
**项目的管理和维护**：模块化和组件化  
**快速加载内容**：异步加载数据，图片的优化处理（如使用更高压缩比webp格式的图片）  
**合理地利用文件缓存**：这样可以大幅度提高网页资源的加载速度，而且幸运的是，浏览器默认可以支持文件缓存，对于一段时间内浏览器的重复请求，服务器可能会返回HTTP的304状态码或者不发送请求，让浏览器直接从本地读取内容。

### 1.2　浏览器应用基础

接收到用户输入的网址后，浏览器会开启一个线程来处理这个请求，对用户输入的URL地址进行分析判断，如果是HTTP协议就按照HTTP方式来处理。○　调用浏览器引擎中的对应方法，比如WebView中的loadUrl方法，分析并加载这个URL地址。○　通过DNS解析获取该网站地址对应的IP地址，查询完成后连同浏览器的Cookie、userAgent等信息向网站目的IP发出GET请求。○　进行HTTP协议会话，浏览器客户端向Web服务器发送报文。○　进入网站后台上的Web服务器处理请求，如Apache、Tomcat、Node.js等服务器。○　进入部署好的后端应用，如PHP、Java、JavaScript、Python等后端程序，找到对应的请求处理逻辑，这期间可能会读取服务器缓存或查询数据库等。○　服务器处理请求并返回响应报文，此时如果浏览器访问过该页面，缓存上有对应资源，会与服务器最后修改记录对比，一致则返回304，否则返回200和对应的内容。○　浏览器开始下载HTML文档（响应报头状态码为200时）或者从本地缓存读取文件内容（浏览器缓存有效或响应报头状态码为304时）。○　浏览器根据下载接收到的HTML文件解析结构建立DOM（DocumentObjectModel，文档对象模型）文档树，并根据HTML中的标记请求下载指定的MIME类型文件（如CSS、JavaScript脚本等），同时设置缓存等内容。○　页面开始解析渲染DOM，CSS根据规则解析并结合DOM文档树进行网页内容布局和绘制渲染，JavaScript根据DOMAPI操作DOM，并读取浏览器缓存、执行事件绑定等，页面整个展示过程完成。

标注(黄色)-1.2　浏览器应用基础>位置425

通常我们认为浏览器主要由七部分组成：用户界面、网络、JavaScript引擎、渲染引擎、UI后端、JavaScript解释器和持久化数据存储。

标注(黄色)-1.2　浏览器应用基础>位置456

这里我们要关注的是渲染树的布局阶段和绘制阶段。页面生成后，如果页面元素位置发生变化，就要从布局阶段开始重新渲染，也就是页面重排，所以页面重排一定会进行后续重绘；如果页面元素只是显示样式改变而布局不变，那么页面内容改变将从绘制阶段开始，也称为页面重绘。

标注(黄色)-1.2　浏览器应用基础>位置460

渲染引擎对DOM渲染树的解析和输出是逐行进行的，所以渲染树前面的内容可以先渲染展示，这样就保证了较好的用户体验。另外也尽量不要在HTML显示内容中插入script脚本等标签，script标签内容的解释执行常常会阻塞页面结构的渲染。

标注(黄色)-1.2　浏览器应用基础>位置465

Webkit内核中的HTML和CSS解析可以认为是并行的；而Gecko则是先解析HTML，生成内容Sink（ContentSink可以认为是构建DOM结构树的工厂方法）后再开始解析CSS。

标注(黄色)-1.2　浏览器应用基础>位置514

仍需要结合CSS规则生成一个带有节点CSS样式描述的DOM树。

标注(橙色)-1.2　浏览器应用基础>位置516

DOM元素标签是指文本化的HTML标识，而DOM元素对象则是指经过渲染引擎DOM解析后生成的具有节点父子关系的树形对象。

标注(蓝色)-1.2　浏览器应用基础>位置530

关于CSS规则的权重计算，一般认为是！important>内联样式规则（权重1000）>id选择器（权重100）>类选择器（权重10）>元素选择器（权重1）。

标注(黄色)-1.2　浏览器应用基础>位置536

数据持久化存储主要是针对浏览器的，所以我们统称为浏览器缓存（

标注(黄色)-1.2　浏览器应用基础>位置539

现代浏览器的8种缓存机制：HTTP文件缓存、LocalStorage、SessionStorage、indexDB、WebSQL、Cookie、CacheStorage、ApplicationCache，另外还有一种使用不太多的Flash缓存方式。

标注(黄色)-1.2　浏览器应用基础>位置547

标注(黄色)-1.2　浏览器应用基础>位置551

服务端判断Etag未修改则返回状态304，修改则返回200，

标注(黄色)-1.2　浏览器应用基础>位置554

HTTP缓存可以在文件缓存生效的情况下让浏览器从本地读取文件，不仅加快了页面资源加载，同时节省网络流量，所以在Web站点配置中要尽可能利用缓存来优化请求过程。在

标注(黄色)-1.2　浏览器应用基础>位置556

一般这里CacheControl设置maxage的时间单位是秒，如果同时设置了Expires和CacheControl，则只有CacheControl的设置生效。<metahttpequiv="Expires"content="Mon,20Jul201623:00:00GMT"/>

标注(蓝色)-1.2　浏览器应用基础>位置570

是，这里的大小限制指的是单个域名下localStorage的大小，所以localStorage中不适合存放过多的数据，如果数据存放超过最大限制可能会读取报错，

标注(蓝色)-1.2　浏览器应用基础>位置577

letrkey=/^[09AZaz_@]*$/;letstore;//转换对象functioninit(){if(typeofstore==='undefined'){store=window['localStorage'];}returntrue;}//判断localStorage的key值是否合法functionisValidKey(key){if(typeofkey!=='string'){returnfalse;}returnrkey.test(key);}exports={//设置localStorage单条记录set(key,value){letsuccess=false;if(isValidKey(key)&&init()){try{value+='';store.setItem(key,value);success=true;}catch(e){}}returnsuccess;},//读取localStorage单条记录get(key){if(isValidKey(key)&&init()){try{returnstore.getItem(key);}catch(e){}}returnnull;},//移除localStorage单条记录remove(key){if(isValidKey(key)&&init()){try{store.removeItem(key);returntrue;}catch(e){}}returnfalse;},//清除localStorage所有记录clear(){if(init()){try{for(letkeyinstore){store.removeItem(key);}returntrue;}catch(e){}}returnfalse;}};module.exports=exports;

备注-1.2　浏览器应用基础>位置599

loocalsrtoage

标注(粉色)-1.2　浏览器应用基础>位置599

单个域名下localStorage的大小是有限制的，但是可以用iframe的方式使用多个域名来突破单个页面下localStorage存储数据的最大限制。

标注(黄色)-1.2　浏览器应用基础>位置609

我们通常认为Cookie的最大长度限制为4KB（

标注(黄色)-1.2　浏览器应用基础>位置622

Cookie设置中有个HttpOnly参数，前端浏览器使用document.cookie是读取不到HttpOnly类型Cookie的，被设置为HttpOnly的Cookie记录只能通过HTTP请求头发送到服务器端进行读写操作，这样就避免了服务器端的Cookie记录被前端JavaScript修改，保证了服务端验证Cookie的安全性。

标注(黄色)-1.2　浏览器应用基础>位置645

WebSQL是浏览器端用于存储较大量数据的缓存机制，不过这只有较新版本的Chrome浏览器支持该机制，并以一个独立浏览器端数据存储规范的形式出现。

标注(黄色)-1.2　浏览器应用基础>位置658

openDatabase()方法可以打开已存在的数据库，并默认创建不存在的数据库。openDatabase()中的五个参数分别为数据库名、版本号、描述、数据库大小、创建回调，即使创建回调为null也可以创建数据库，transaction()方法允许我们根据情况控制执行事务提交或回滚，executeSql()则用于执行真实的SQL查询语句。

标注(黄色)-1.2　浏览器应用基础>位置674

和WebSQL类似，目前使用IndexDB的实际应用场景也不是很多，而且将大量数据保存到本地也会造成数据泄露，

标注(黄色)-1.2　浏览器应用基础>位置687

图114　ApplicationCache文件访问与更新机制

标注(黄色)-1.2　浏览器应用基础>位置727

要了解cacheStorage，我们必须深入了解一下ServiceWorker，ServiceWorker与WebWorker一样是在浏览器后台作为一个独立的线程运行的JavaScript脚本，可以为浏览器提供并行的计算和数据处理能力，并通过message/postMessage方法在页面之间进行通信，但是不能与前端界面进行交互。我们知道NativeAPP（一般指移动客户端的原生应用）可以做到消息推送、离线使用、自动更新等，同样地，如果使用ServiceWorker也可以让Web应用具有类似功能。

标注(黄色)-1.2　浏览器应用基础>位置759

只有HTTP缓存、localStorage和Cookie。ServiceWorker在将来可能会被使用，但目前兼容性的欠缺仍然不能忽视，其他的缓存方式我们仅作为知识了解即可。

标注(黄色)-1.3　前端高效开发技术>位置791

自文档化代码的编写也是一个很好的习惯。

标注(黄色)-1.3　前端高效开发技术>位置803

用F12打开控制台后，

标注(粉色)-1.3　前端高效开发技术>位置819

Audits则可以根据目前页面文档加载和脚本执行情况给出当前前端页面的部分优化建议，这对于前端页面的优化具有极其重要的借鉴意义。

标注(粉色)-1.3　前端高效开发技术>位置822

例如，在Chrome地址栏中输入chrome://inspect/#devices即可查看主机当前连接的移动设备浏览器打开网页的情况，并可以阅读DOM结构和查看Debug信息。

标注(粉色)-1.3　前端高效开发技术>位置831

Fiddler，

标注(蓝色)-1.3　前端高效开发技术>位置844

服务端开发调试的工具也比较多。例如nodesupervisor、nodeinspector及以后可能出现的新工具。这类工具入门很简单，

第2章　前端与协议

标注(黄色)-位置892

基于SSL（SecureSocketsLayer，安全套接字层）层的HTTPS协议。

标注(黄色)-位置894

与移动端Native原生程序交互的协议。

标注(黄色)-位置894

HTML5的WebSocket实时通信协议、与服务端交互的RESTful协议等。

标注(黄色)-2.1　HTTP协议简介>位置897

HTTP（HyperTextTransportProtocol，超文本传输协议）协议是WWW服务器和用户请求代理（例如浏览器等）之间通过应答请求模式传输超文本（例如HTML文件、JavaScript文件、CSS文件、图片甚至服务器接口数据等）内容的一种协议，

标注(蓝色)-2.1　HTTP协议简介>位置900

浏览器（用户请求代理）向服务器发送请求时头部中包含请求的方法GET、URL（UniformResourceLocation，统一资源定位符）http://www.jixianqianduan.com/、协议版本号1.1、请求头域字段（如请求接受类型Accept）、缓存控制CacheControl、浏览器Cookie和userAgent信息等，同时也可能会带上请求的正文内容。

标注(蓝色)-2.1　HTTP协议简介>位置903

响应的内容包括HTTP消息响应的协议版本1.1、返回码304及返回描述NotModified、缓存控制信息CacheControl以及正文的HTML内容等，

标注(蓝色)-2.1　HTTP协议简介>位置908

通常一个完整的HTTP报文由头部、空行、正文三部分组成。空行用于区分报文头部和报文正文，由一个回车符和一个换行符组成。

标注(黄色)-2.1　HTTP协议简介>位置920

提到HTTP1.1协议，我们首先想到的一个重要特性就是长连接。

标注(蓝色)-2.1　HTTP协议简介>位置924

但是在HTTP1.1协议中，任何HTTP请求的报文头部域都会默认包含keepalive.keepalive的控制可以让客户端到服务器端之间的连接在一段时间内持续有效，

标注(黄色)-2.1　HTTP协议简介>位置933

例如WebSocket协议就是典型的应用，WebSocket协议通信是通过HTTP的方式来建立的，通信连接建立完成后通知服务器切换到WebSocket协议来完成后面的数据通信。

标注(蓝色)-2.1　HTTP协议简介>位置936

通信，如果服务端支持WebSocket服务并允许该客户端来连接，则可以在响应报文头中返回Upgrade和Connection消息头域，同意浏览器使用WebSocket来连接，同时返回的状态码为101表示请求还需要完成协议的切换。

标注(黄色)-2.1　HTTP协议简介>位置941

HTTP1.1增加了CacheControl头域，可以支持maxage用来表示相对过期时间，另外请求服务器时也可以根据Etag和LastModified来判断是否从浏览器端缓存中加载文件，此时缓存的控制和判断将决定服务器的响应报文中头部内容的状态码200还是304。

标注(黄色)-2.1　HTTP协议简介>位置951

这就是CacheControl、Etag和LastModified控制请求缓存的

标注(黄色)-2.1　HTTP协议简介>位置954

部分内容传输优化指HTTP可以支持超文本文件的部分传输，

标注(黄色)-2.1　HTTP协议简介>位置993

Etag：对象（比如URL）的标志值。一个对象（如HTML文件）如果被修改了，其Etag也会被修改，所以Etag的作用和LastModified差不多，主要供Web服务器判断一个对象是否改变。例如前一次请求某个HTML文件时获得了其Etag，当这次又请求该文件时，浏览器就会把先前获得的Etag值发送给Web服务器，然后Web服务器会将这个Etag值跟该文件当前的Etag值进行对比，判断文件是否改变。

标注(橙色)-2.1　HTTP协议简介>位置1024

SPDY是一种基于HTTP的兼容协议，由Google发起，Chrome、Opera、Firefox等较新的浏览器已提供该协议支持。SPDY传输支持多路复用和服务器推送技术，压缩了HTTP头部减小了请求大小，并强制使用SSL传输协议，到目前为止已经成为了一套成熟的高效协议标准。

标注(蓝色)-2.1　HTTP协议简介>位置1030

HTTP2采用完全二进制的格式来传输数据，而非HTTP1.x的默认文本格式。而二进制在网络中传输的基本单位一般为帧（

标注(蓝色)-2.1　HTTP协议简介>位置1035

HTTP2使用TCP多路复用的方式来降低网络请求连接建立和关闭的开销，

备注-2.1　HTTP协议简介>位置1036

采用多路复用技术能把多个信号组合起来在一条物理信道上进行传输，在远距离传输时可大大节省电缆的安装和维护费用。频分多路复用FDM(FrequencyDivisionMultiplexing)和时分多路复用TDM(TimeDivisionMultiplexing)是两种最常用的多路复用技术。

标注(蓝色)-2.1　HTTP协议简介>位置1038

这里我们有必要明确一下TCP连接复用和HTTP1.1中keepalive连接复用的区别：TCP复用传输是发生在传输层的，而keepalive控制的文件的连接复用是在应用层的；keepalive的连接复用是串行的，即一个文件传输完后，下个文件才能复用这个连接，

标注(黄色)-2.2　web安全机制>位置1059

XSS（CrossSiteScript，跨站脚本攻击）、SQL（StructuredQueryLanguage，结构化查询语言）注入和CSRF（CrosssiteRequestForgery，跨站请求伪造）均属于基础的前端安全知识，逐个来看一下。

标注(黄色)-2.2　web安全机制>位置1061

XSS通常是由带有页面可解析内容的数据未经处理直接插入到页面上解析导致的。

标注(黄色)-2.2　web安全机制>位置1062

XSS分为存储型XSS、反射型XSS、MXSS（也叫DOMXSS）三种。

标注(黄色)-2.2　web安全机制>位置1063

存储型XSS的攻击脚本常常是由前端提交的数据未经处理直接存储到数据库然后从数据库中读取出来后又直接插入到页面中所导致的；反射型XSS可能是在网页URL参数中注入了可解析内容的数据而导致的，如果直接获取URL中不合法的并插入页面中则可能出现页面上的XSS攻击；MXSS则是在渲染DOM属性时将攻击脚本插入DOM属性中被解析而导致的。XSS主要的防范方法是验证输入到页面上所有内容来源数据是否安全，如果可能含有脚本标签等内容则需要进行必要的转义。具体看下面几个例子。

标注(蓝色)-2.2　web安全机制>位置1077

一般的做法是将所有可能包含攻击的内容进行HTML字符编码转义，目前的HTML字符编码解码就可以如下实现。

标注(蓝色)-2.2　web安全机制>位置1089

SQL注入攻击主要是因为页面提交数据到服务器端后，在服务器端未进行数据验证就将数据直接拼接到SQL语句中执行，因此产生执行与预期不同的现象。主要防范措施是对前端网页提交的数据内容进行严格的检查校验。

标注(黄色)-2.2　web安全机制>位置1095

CSRF是指非源站点按照源站点的数据请求格式提交非法数据给源站点服务器的一种攻击方法。

标注(黄色)-2.2　web安全机制>位置1098

通常比较安全的是通过页面Token（令牌）提交验证的方式来验证请求是否为源站点页面提交的，来阻止跨站伪请求的发生。

标注(蓝色)-2.2　web安全机制>位置1108

其中一种形式是将页面提交到后台的验证Token与session临时保存的Token进行比较就可以来实现了。

标注(蓝色)-2.2　web安全机制>位置1114

标注(黄色)-2.2　web安全机制>位置1122

网络请求劫持的发生也越来越频繁。网络劫持一般指网站资源请求在请求过程中因为人为的攻击导致没有加载到预期的资源内容。网络请求劫持目前主要分为两种：DNS劫持与HTTP劫持。

标注(黄色)-2.2　web安全机制>位置1125

取得某域名的解析记录控制权，进而修改此域名的解析结果，导致用户对该域名地址的访问由原IP地址转入到修改后的指定IP地址的现象，

标注(黄色)-2.2　web安全机制>位置1136

一般用户请求源网站的IP地址及网站加载的内容和脚本都是正确的，但是在网站内容请求返回的过程中，可能被ISP（InternetServiceProvider，互联网服务提供商）劫持修改，最终在浏览器页面上添加显示一些广告等内容信息。

标注(黄色)-2.2　web安全机制>位置1141

HTTPS协议是通过加入SSL（SecureSocketsLayer）层来加密HTTP数据进行安全传输的HTTP协议，同时启用默认的443端口进行数据传输。

标注(黄色)-2.2　web安全机制>位置1142

HTTPS是怎样保证浏览器和服务器之间数据安全传输的呢？我们需要先理解两个概念：公钥和私钥。

标注(黄色)-2.2　web安全机制>位置1148

客户端在需要使用HTTPS请求数据时，首先会发起连接请求，告诉服务器将建立HTTPS连接；服务器收到通知后自己生成一个公钥并将它返回给客户端，如果是第一次请求，同时还要告诉客户端需要进行连接验证；如果需要验证，客户端接收到服务器公钥后开始发送验证请求，将一个特定的验证串使用服务器返回的公钥加密后形成密文发送给服务器，同时客户端也将自己生成的公钥发送给服务器；服务器获取到加密的报文和客户端公钥，先使用服务器私钥解密报文获得验证串，然后将验证串通过接收到的客户端公钥加密后返回给客户端；客户端再通过私钥解密验证串，判断是否为自己开始发送的验证串；如果正确，说明双方的连接是安全的，连接验证成功，客户端开始将后面的数据通过服务器初始返回的公钥不断加密发送给服务器，服务器也不断解密获取报文，并通过客户端公钥加密响应的报文内容返回给客户端验证。这样就建立了HTTPS双向的加密传输连接。

标注(黄色)-2.2　web安全机制>位置1158

HTTPS的请求只能被添加了对应数字证书的应用层代理拦截，

标注(黄色)-2.2　web安全机制>位置1159

Node端就可以用以下方法来实现。//引入https模块consthttpsModule=require('https');constfs=require('fs');//加载网站https服务证书文件，证书一般需要注册申请consthttps=httpsModule.Server({key:fs.readFileSync('/path/to/server.key'),cert:fs.readFileSync('/path/to/server.crt')},function(req,res){res.writeHead(200);res.end("helloworld\n");});//https默认监听端口443https.listen(443,function(err){console.log("httpslisteningonport:443");});当然，如果使用Web框架，也可以通过更简单的方式创建一个HTTPS服务器。constkoa=require('koa');constapp=koa();//同时监听多个端口app.listen(80);app.listen(443);

标注(黄色)-2.2　web安全机制>位置1169

RemoteAddress:192.30.252.131:443

标注(黄色)-2.2　web安全机制>位置1171

upgradeinsecurerequests，

标注(黄色)-2.2　web安全机制>位置1172

使用HTTPS来加载HTML文件，而HTML中加载的是HTTP链接的资源文件，则会产生MixedContent类型的错误，

标注(黄色)-2.2　web安全机制>位置1189

很多浏览器内置了一个配置STS的站点列表，

标注(黄色)-2.2　web安全机制>位置1204

blockallmixedcontent就是之前提到的，HTTPS请求的HTML会控制阻塞外部HTTP资源的文件加载。

标注(黄色)-2.2　web安全机制>位置1212

AccessControlAllowOrigin常常作为跨域共享设置的一种实现方式，其他常用的跨域手段还有：JSONP(JSONwithPadding)、script标签跨域、window.postMessage、修改document.domain跨子域、window.name跨域和WebSocket跨域等。

标注(黄色)-2.3　前端实时协议>位置1222

目前可用来在前端浏览器上进行实时通信的功能实现方式主要有WebSocket、Poll、Longpoll和DDP协议。

标注(黄色)-2.3　前端实时协议>位置1238

0x8表示连接关闭；○　0x9表示ping；

标注(黄色)-2.3　前端实时协议>位置1242

值得注意的是，WebSocket在网络中传输的最小单位也为帧，

标注(黄色)-2.3　前端实时协议>位置1260

Longpoll目前一个很典型的应用场景就是网站通过对应的移动客户端进行扫描二维码登录，即用户使用移动客户端扫描二维码登录网站，成功后桌面浏览器页面自动响应跳转进入一个新的登录后页面。

标注(黄色)-2.3　前端实时协议>位置1266

差别。图216　二维码扫描登录跳转原理function_getQrAuth(){

标注(黄色)-2.5　与Native交互协议>位置1377

首先来看一下HybridApp中如何通过URI请求在HTML5前端页面中来调用一个Native的方法或界面。其主要原理是，Native应用可在移动端系统中注册一个Scheme协议的URI，这个URI可在系统的任意地方授权访问来调起一段原生方法或一个原生的界面。

第3章　前端三层结构与应用

标注(黄色)-位置1481

简单来讲，例如HTML开发可以由Component（实现的形式较多，例如WebComponent、目录级Component、其他框架自定义形式的Component）来管理结构，CSS由SASS、postCSS、stylus等预处理器的语法开发来代替，JavaScript则使用ECMAScript6+、TypeScript等特性标准进行高效开发。

标注(黄色)-3.1　HTML结构层基础>位置1509

Web语义化是指在HTML结构的恰当位置上使用语义恰当的标签，使页面具有良好的结构，使页面标签元素具有含义，能够让人或搜索引擎更容易理解。

标注(黄色)-3.1　HTML结构层基础>位置1554

CSS规范规定：每个标签元素都是有display属性的。

标注(黄色)-3.1　HTML结构层基础>位置1578

再如页面中使用<table>这个语义化标签是会导致内容渲染较慢的，因为<table>里面的内容渲染是等表格内容全部解析完生成渲染树后一次性渲染到页面上的，如果表格内容较多，就可能产生渲染过程较慢的问题，因此我们常常需要通过其他的方式来模拟<table>元素，例如使用无序列表来模拟表格。

标注(黄色)-3.1　HTML结构层基础>位置1598

实际项目开发中，我们常常把<i>元素标签当作页面上的icon图标标签来使用>

标注(黄色)-3.1　HTML结构层基础>位置1615

<img>标签的alt属性和title属性是有区别的，alt属性一般表示图片加载失败时提示的文字内容，title属性则指鼠标放到元素上时显示的提示文字。在页面结构书写中，我们常用title来提示一些省略掉的文字的全部内容。例如<ptitle="这是一段很长的文字，包含很多内容">这是一段很长的文字…</p>，这样在页面中可能只展示部分文字，但用户可以通过鼠标提示看到这段文字的完整内容，这对

标注(黄色)-3.1　HTML结构层基础>位置1636

不同的是AMPHTML是通过自定义元素完成Component来实现的，懒加载则是通过JavaScript直接在网页中操作实现。

标注(黄色)-3.1　HTML结构层基础>位置1638

浏览器同一个域名的最大并行下载线程个数是有限的，所以我们常常要先加载页面的关键性展示资源，延后加载页面脚本类资源或页面的非关键性图片资源。一般浏览器（IE8以上）对同一个域名下的资源最多支持4～6个并行下载数，所以为了增大资源下载并行数，我们常常将HTML、JavaScript、CSS、图片资源分域存放。分域也可以将静态资源请求进行服务器端的负载均衡，并对请求中的cookie信息进行隔离，因为跨域请求默认是不带Cookie的，这样便减小了JavaScript、CSS、图片等资源的请求头部信息大小，从而提升了请求的解析速度。

标注(黄色)-3.1　HTML结构层基础>位置1654

使用AMP提升页面性能的基本的原则如下。○　只允许异步的script脚本○　只加载静态的资源○　不能让内容阻塞渲染○　不在关键路径中加载第三方JavaScript○　所有的CSS必须内联○　字体使用声明必须高效○　最小化样式声明○　只运行GPU加速的动画○　处理好资源加载顺序问题○　页面必须立即加载○　提升AMP元素性能

标注(黄色)-3.2　前端结构层演进>位置1706

曾经我们甚至一度认为前端页面技术就是CSS+DIV技术，当然这是在前端技术发展早期，HTML的元素主要分为行内、块级和常见空元素几类。

标注(黄色)-3.2　前端结构层演进>位置1713

目前由于移动端浏览器内核具有相对较好的统一性和兼容性，所以HTML5主要用于移动端页面的开发。

标注(黄色)-3.2　前端结构层演进>位置1772

也就是说，你自己写的CSS选择器和JavaScript代码都不会影响到ShadowDOM里面的内容。实质上就是让<video>标签里的逻辑和样式都被浏览器单独封装并与外界元素独立，而<video>标签内容在浏览器上的渲染则是在浏览器结构UI后端模块中设置的。

标注(黄色)-3.2　前端结构层演进>位置1775

ShadowDOM是HTML的一个规范，它允许浏览器开发者封装自己的HTML标签、CSS样式和特定的JavaScript代码，同时也可以让开发人员创建类似<video>这样的自定义一级标签，创建这些新标签内容和相关的API被称为WebComponent。这里提出了ShadowDOM和WebComponent

标注(黄色)-3.4　JavaScript标准实践>位置2068

三是使用let、const在全局作用域下声明的变量不会作为属性添加到全局作用域对象里面，这点和var是不同的；四是通过测试，使用let、const赋值语句的执行速度比使用var快约65%左右。

标注(黄色)-3.4　JavaScript标准实践>位置2070

区别：模块内不变的引用和常量，一般使用const定义；可变的变量或引用使用let声明；var仅用于声明函数整个作用域内需要使用的变量。

标注(黄色)-3.4　JavaScript标准实践>位置2079

的。解构赋值个人

标注(黄色)-3.4　JavaScript标准实践>位置2089

需要注意的是，这里的…进行的数组复制是浅拷贝（

标注(黄色)-3.4　JavaScript标准实践>位置2128

在JavaScript中，代码的执行上下文由变量对象、作用域链和this值组成。但箭头函数与外层执行上下文共享this值。如果需要创建具有独立上下文的函数，就不要使用箭头函数。

标注(黄色)-3.4　JavaScript标准实践>位置2164

所以数组循环遍历最佳方式是for...of，此外for...of也可以用来遍历Map、Set、WeakMap、WeakSet等集合。

标注(黄色)-3.4　JavaScript标准实践>位置2167

纯函数一般指返回值完全由传入的参数来决定的函数，即对于同一个参数输入，在任何情况下的函数返回结果都是相同且唯一的。例如数组的slice()可以认为是一个纯函数，而random()则不是纯函数。

标注(黄色)-3.4　JavaScript标准实践>位置2181

我们可以把Interator理解成为数组或对象上的一个根据偏移来访问内存内容的游标对象，每次调用next()，遍历游标会向后移动一个地址。

标注(黄色)-3.4　JavaScript标准实践>位置2192

代码很浅显易懂，不过需要注意的是，Generator遇到yield关键字会暂停往后执行，但并不表示后面的程序就不执行了。如果console.log(number)是一个耗时的工作，那么程序只在Generator里面暂停，外面的程序仍会继续执行，

标注(黄色)-3.4　JavaScript标准实践>位置2213

如果一定要对应来看，Set可以认为是增强的数组类型，Map则可以认为是增强的对象类型，WeakSet和WeakMap则对应着Set和Map的优化类型，所以某种程度上，为了让程序开发更加方便，我们有必要引入集合这类更为高效的类型。WeakSet和WeakMap在生成时有更加严格的限制：WeakSet只存储对象类型的元素，不能遍历，没有size属性；WeakMap只接受基本类型的值作为键名，没有keys、values、entries等遍历方法，也没有size属性。

标注(黄色)-3.4　JavaScript标准实践>位置2218

需要注意的是，Map和Set都为内部的每个键或值保持了强引用，也就是说，如果一个存储的属性元素被移除了，回收机制可能无法回收它占用的内存，容易造成内存泄露，所以我们使用时要尽可能先删除引用的相关内容。相比之下，使用WeakSet和WeakMap则不会出现上述情况，因为它们并不使用强引用。再总结一下JavaScript可能出现内存泄露的常见场景：闭包函数、全局变量、对象属性循环引用、DOM节点删除时未解绑事件、Map和Set的属性直接删除。希望大家同时也要明白上述五种场景的具体情况是怎么样的。
